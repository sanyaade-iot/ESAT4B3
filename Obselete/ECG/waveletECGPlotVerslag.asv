%% Initialization
addpath('../../Data')
load('100m.mat')
samplefreq = 360;
seconds = 2;
offset = 0;
ecg = val(1,1+offset:samplefreq*seconds+offset); % Neem één frame uit de input-data
time = (0+offset:samplefreq*seconds-1+offset)/samplefreq; % de tijd in seconden van elke sample

noise = 360*sin(time*2*pi/8) + 36*sin(time*2*pi*50) + 2*wgn(samplefreq*seconds,1,0)'; % 0.5 and 50 Hz + white gaussian noise
noisy = ecg + noise;

figure
hold on
%plot(time, ecg)
plot(time, noisy)

%% Wavelet transformations
wv = 'sym4'; % Symlet 4 heeft ongeveer dezelfde vorm als een QRS complex, en is orthogonaal, dus kan real-time berekend worden

wtecg = modwt(ecg, wv); % pas de discrete wavelet-transformatie toe op het ECG-signaal
wtrec = zeros(size(wtecg)); % maak een matrix met dezelfde dimensies als het resultaat en vul ze met nullen
wtrec(4:5,:) = wtecg(4:5,:); % kopiëer level 4 en 5 van het resultaat naar de nieuwe matrix
ecgfiltered = imodwt(wtrec, wv); % voer de inverse discrete wavelet-transformatie toe op de nieuwe matrix

% do the same thing for the noisy signal
wtnoisy = modwt(noisy,wv);
wtrecnoisy = zeros(size(wtnoisy));
wtrecnoisy(3:5,:) = wtnoisy(3:5,:);
noisyfiltered = imodwt(wtrecnoisy,wv);

%% Plotting
%plot(time, ecgfiltered)
%plot(time, noisyfiltered)
%plot(time, ecgfiltered.^2/30)
%plot(time, noisyfiltered)
plot(time, noisyfiltered.^2/30)

fourier = fft(noisyfiltered);
frequencies = ((1:seconds*samplefreq)-1) * samplefreq / (seconds*samplefreq);

figure
axis tight
plot(frequencies, fourier)


